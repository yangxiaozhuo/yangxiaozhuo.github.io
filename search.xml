<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis VS MySql，到底谁更快？（一）</title>
      <link href="/2022/10/21/weiChat/redis/redis1/"/>
      <url>/2022/10/21/weiChat/redis/redis1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>：“redis为什么比Mysql快？”</p><p>我相信这是大家只要学过redis或者看过面试题都会遇到也都会回答的一个问题。那么，我突然想到一个问题：redis一定比mysql快吗？</p><p>答案是：不一定！</p><p>今天看着黑马点评的项目，突然想到，redis是不是一定比mysql快呢？所以就去各大主流程序员网站进行搜索，包括掘金，csdn。只在csdn中只找到了一篇文章有进行对比测试，采用jmeter测试得出redis比mysql快接近6倍。</p><p><img src="/gallery/img/weiChat/redis01/01.%E6%8E%98%E9%87%91%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C.webp" alt="01.掘金搜索结果"></p><p><img src="/gallery/img/weiChat/redis01/02.csdn%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C.webp" alt="02.csdn搜索结果"></p><p>没找到答案的我，针对于这个疑问，我做了以下几场测试。  </p><h1 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h1><p>测试1测试平台如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql-8.0.29</span>  <span class="string">在本机运行</span></span><br><span class="line"><span class="string">虚拟机CentOS7.6</span> <span class="string">分一核二线程，2G运行内存</span></span><br><span class="line"><span class="string">redis-6.2.6</span>   <span class="string">在虚拟机运行</span></span><br><span class="line"><span class="string">测试数据库hmdp中，tb_user表查询</span></span><br></pre></td></tr></table></figure><p>这里我们先连接上本机的数据库，并在redis中添加key为user的数据。</p><p><img src="/gallery/img/weiChat/redis01/03.%E6%B5%8B%E8%AF%951%E9%85%8D%E7%BD%AE.webp" alt="03.测试1配置"></p><p><img src="/gallery/img/weiChat/redis01/04.redis%E5%A2%9E%E5%8A%A0%E6%95%B0%E6%8D%AE.webp" alt="04.redis增加数据"></p><p>编写连接测试的代码，运行后可以拿到两边的测试数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> UserServiceImpl userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMysql</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">mysqlValue</span> <span class="operator">=</span> userService.query().eq(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>).one();</span><br><span class="line">    System.out.println(<span class="string">&quot;mysql连接成功，查询的值为&quot;</span> + mysqlValue);</span><br><span class="line">    <span class="type">String</span> <span class="variable">redisValue</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;redis连接成功，查询的值为&quot;</span> + redisValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/gallery/img/weiChat/redis01/05.%E6%B5%8B%E8%AF%95%E9%93%BE%E6%8E%A5.webp" alt="05.测试链接"></p><p>测试编写代码，大量查询redis和mysql，这里我们分别查询1次，10次，100次，1000次，10000次，100000次比较结果。测试代码和结果如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> UserServiceImpl userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisAndMysql</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> start;</span><br><span class="line">    <span class="type">long</span> end;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; times; j++) &#123;</span><br><span class="line">            userService.query().eq(<span class="string">&quot;id&quot;</span>,<span class="number">1</span>).count();</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(times + <span class="string">&quot;次 \t查询mysql数据库耗时&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; times; j++) &#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(times + <span class="string">&quot;次 \t查询redis数据库耗时&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        times = times * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/gallery/img/weiChat/redis01/06.%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C.webp" alt="06.第一次比较结果"></p><p><img src="/gallery/img/weiChat/redis01/07.01.%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%9F%B1%E7%8A%B6%E5%9B%BE.webp" alt="07.01.第一次比较结果柱状图"></p><p><img src="/gallery/img/weiChat/redis01/07.02.%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%9F%B1%E7%8A%B6%E5%9B%BE.webp" alt="07.02.第一次比较结果柱状图"></p><p>第一次查询两者都耗时较久，这归因于启动项目后第一次建立连接的原因，也算是为后面的几轮测试做好初始化。  </p><p>不难发现，结果可谓是令人大跌眼镜啊！在数据量较小时，1000次以下时，redis还是明显比mysql要快的，但是还是无法做到好几倍的优化效果。当数据量来到到一万次时，redis居然直接被mysql甩下一个身位！？！？这是为什么？？要知道，redis存储的user数据，是用key去直接读取的；mysql的tb_user表下还有上千条数据，使用B+树排序搜索的。  </p><p><strong>是不是因为mysql的环境就直接和idea都在本机？而redis运行在虚拟机上？</strong>  </p><p>带着这个疑问，我又在虚拟机上安装了mysql数据库，创建了一个user表，只增加了一条数据。（这里安装mysql和远程连接又踩了很多坑，看到这里的小伙伴看在我被坑的不浅的份上，可以留下一个大大的赞吗~）</p><h1 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h1><p>测试2测试平台如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">虚拟机CentOS7.6</span> <span class="string">分一核二线程，2G运行内存</span></span><br><span class="line"><span class="string">mysql-5.7.26</span>  <span class="string">在虚拟机运行</span></span><br><span class="line"><span class="string">redis-6.2.6</span>   <span class="string">在虚拟机运行</span></span><br><span class="line"><span class="string">测试数据库hmdp中，tb_user表查询（只有一条数据）</span></span><br></pre></td></tr></table></figure><p>更改配置文件，连接数据库，并运行测试代码测试是否连接成功连接。</p><p><img src="/gallery/img/weiChat/redis01/08.%E6%B5%8B%E8%AF%952%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.webp" alt="08.测试2的配置文件"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> UserServiceImpl userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMysql</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">mysqlValue</span> <span class="operator">=</span> userService.query().eq(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>).one();</span><br><span class="line">    System.out.println(<span class="string">&quot;mysql连接成功，查询的值为&quot;</span> + mysqlValue);</span><br><span class="line">    <span class="type">String</span> <span class="variable">redisValue</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;redis连接成功，查询的值为&quot;</span> + redisValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/gallery/img/weiChat/redis01/09.%E6%B5%8B%E8%AF%952%E6%B5%8B%E8%AF%95%E8%BF%9E%E6%8E%A5.webp" alt="09.测试2测试连接"></p><p>这里看到我们成功的把小白同学查出来了，再同理运行多次查询的测试方法。得到查询耗时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> UserServiceImpl userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisAndMysql</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> start;</span><br><span class="line">    <span class="type">long</span> end;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; times; j++) &#123;</span><br><span class="line">            userService.query().eq(<span class="string">&quot;id&quot;</span>,<span class="number">1</span>).count();</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(times + <span class="string">&quot;次 \t查询mysql数据库耗时&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; times; j++) &#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(times + <span class="string">&quot;次 \t查询redis数据库耗时&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        times = times * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/gallery/img/weiChat/redis01/10.%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C.webp" alt="10.第二次比较结果.png"></p><p><img src="/gallery/img/weiChat/redis01/11.01%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%9F%B1%E7%8A%B6%E5%9B%BE.webp" alt="11.01第二次比较结果柱状图.png"></p><p><img src="/gallery/img/weiChat/redis01/12.02%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%9F%B1%E7%8A%B6%E5%9B%BE.webp" alt="11.02第二次比较结果柱状图.png"></p><p>这里我们可以看出，抛出了虚拟机和本地环境的影响之后，redis确实能比mysql快​上一些。但是效果并不是很明显，这与初学redis的我起初认为redis会比mysql快上数倍甚至数十倍的想法大相径庭。毕竟第一印象就是redis是基于内存的，mysql却是基于硬盘的（而且我的mysql和虚拟机均安装在机械硬盘上，不知如果安装在固态上，能否加速）</p><p>当然，这里测试的情况过于单一，只是单用户单线程多次查询。</p><p>如果是单线程多次修改呢？如果是多线程查询呢​？后面我会再进行进一步的测试，来对比redis和mysql的运行效果。</p><p><img src="/gallery/img/weiChat/redis01/mysql%E5%9B%BE%E6%A0%87.webp" alt="mysql图标"></p><p><img src="/gallery/img/weiChat/redis01/redis%E5%9B%BE%E7%89%87.webp" alt="redis图片"></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常和集合</title>
      <link href="/2021/12/20/java/%E5%BC%82%E5%B8%B8%E5%92%8C%E9%9B%86%E5%90%88/"/>
      <url>/2021/12/20/java/%E5%BC%82%E5%B8%B8%E5%92%8C%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h2><p>异常就是当程序执行到一段代码，发生异常后，就<code>new</code>一个对应的类的对象，这个类是一个异常类，如：<code>NullPointerException</code>和<code>NumberFormatException</code>，然后<code>throw</code>或者<code>catch</code>，<code>throw</code>就是抛出一个异常，和<code>return</code>对比。</p><table><thead><tr><th>throw</th><th>return</th></tr></thead><tbody><tr><td>异常退出</td><td>正常退出</td></tr><tr><td>throw后执行的代码不定，看异常处理机制动态决定</td><td>返回位置确定：上一级调用者</td></tr></tbody></table><h2 id="try-x2F-catch"><a href="#try-x2F-catch" class="headerlink" title="try&#x2F;catch"></a>try&#x2F;catch</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;请输入一个数字&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">  System.out.println(num);</span><br><span class="line">&#125; <span class="keyword">catch</span>(NumberFormatException e) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;参数&quot;</span> + arg[<span class="number">0</span>] + <span class="string">&quot;不是有效数字，请输入数字&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在try内跑出来异常，可以由catch来捕获，捕获后程序还会继续运行而不会退出，只是try后续的代码不会执行。</p><h2 id="异常类体系-记下来"><a href="#异常类体系-记下来" class="headerlink" title="异常类体系(记下来)"></a>异常类体系(记下来)</h2><p><img src="/gallery/img/%E5%BC%82%E5%B8%B8%E5%92%8C%E9%9B%86%E5%90%88/%E5%BC%82%E5%B8%B8%E7%B1%BB%E4%BD%93%E7%B3%BB%E5%9B%BE.webp" alt="异常类体系图.webp"></p><p>Throwable是所有异常类的基类，他有两个子类Error和Exception。</p><p>Error表示系统错误或资源耗尽，应用程序不抛出或处理，虚拟机错误及其子类，内存溢出错误和栈溢出错误。Error及子类都是未受检异常。</p><p>Exception中有很多子类，也可以继承Exception自定义异常，其中列出来数据库异常，IO异常，和运行时异常（未受检异常）受检异常不能通过编译。</p><table><thead><tr><th><strong>异常</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>NullPointerException</code></td><td>空指针异常</td></tr><tr><td><code>IllegalStateException</code></td><td>非法状态</td></tr><tr><td><code>ClassCastException</code></td><td>非法强制类型转换</td></tr><tr><td><code>IllegalArgumentException</code></td><td>参数错误</td></tr></tbody></table><table><thead><tr><th><strong>异常</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>NumberFormatException</code></td><td>数字格式错误</td></tr><tr><td><code>IndexOutOfBoundsException</code></td><td>索引越界</td></tr><tr><td><code>ArrayIndexOutOfBoundsException</code></td><td>数组索引越界</td></tr><tr><td><code>StringIndexOutOfBoundsException</code></td><td>字符串索引越界</td></tr></tbody></table><p>这些异常大部分只是定义了几个父类的构造函数。</p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>然后自定义异常继承的RuntimeException或他的某个子类，则自定义异常也是未受检异常；如果继承的是Exception和Exception其他子类，则自定义异常是受检异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> AppException &#123;<span class="built_in">super</span>();&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AppException</span><span class="params">(String message, Throwable cause)</span> &#123;<span class="built_in">super</span>(message, cause);&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AppException</span><span class="params">(String message)</span> &#123;<span class="built_in">super</span>(message);&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AppException</span><span class="params">(Throwable cause)</span> &#123;<span class="built_in">super</span>(cause);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常处理包括catch、throw、finally、try-with-resources和throws</p><h3 id="catch匹配"><a href="#catch匹配" class="headerlink" title="catch匹配"></a>catch匹配</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">&#125;<span class="keyword">catch</span>(NumberFormatException e)&#123;</span><br><span class="line">&#125;<span class="keyword">catch</span>(RuntimeException e)&#123;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上方异常要是下方异常的子类，java7开始支持一种新语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionA | ExceptionB e) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="throw和finally"><a href="#throw和finally" class="headerlink" title="throw和finally"></a>throw和finally</h3><p>处理完异常之后，可以通过throw抛出异常给上一层，可以是原来的异常，也可以是新异常。</p><p>finally内代码，无论有无异常发生都会执行。</p><ol><li><p>如果没有异常发生，try执行后执行finally</p></li><li><p>如果有异常被catch，catch执行后执行finally</p></li><li><p>如果有异常发生但没被catch，在异常被抛出前执行finally</p></li></ol><p>注意：如果try或catch中有return时，也会先执行完finally中的代码再去执行return；如果finally内有return或抛出异常，则会覆盖掉catch和try中的return和异常。</p><h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h3><p>finally一般用于释放资源，java7之前要实现AutoCloseable接口之后，在finally中调用<code>close()</code>方法，代码如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useResource</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="type">AutoCloseable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;hello&quot;</span>);   <span class="comment">//创建资源</span></span><br><span class="line">  <span class="keyword">try</span>&#123;               <span class="comment">//使用资源</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    r.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java7支持了一种新语法，在执行完try语句之后自动执行<code>close()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useResource</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">try</span> (<span class="type">AutoCloseable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;hello&quot;</span>))&#123; <span class="comment">//创建资源</span></span><br><span class="line">     <span class="comment">//使用资源  </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h3><p>throws跟在方法后面，可以声明多个异常，以逗号分隔。表示：这个方法可能会抛出这些异常，且没有处理或者没有处理完，调用者必须进行处理。</p><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><img src="/gallery/img/%E5%BC%82%E5%B8%B8%E5%92%8C%E9%9B%86%E5%90%88/%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88%E5%9B%BE%E7%89%87.webp" alt="单列集合图片.webp"></p><p><img src="/gallery/img/%E5%BC%82%E5%B8%B8%E5%92%8C%E9%9B%86%E5%90%88/%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88%E5%9B%BE%E7%89%87.webp" alt="双列集合图片.webp"></p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(Object obj)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection c)</span>;</span><br><span class="line"><span class="comment">//delete</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object obj)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection c)</span>;</span><br><span class="line"><span class="comment">//justice</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object obj)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection c)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//iterator</span></span><br><span class="line">Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//length</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection c)</span>;</span><br></pre></td></tr></table></figure><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>存取有序，有索引，元素可重复</p><h3 id="ArrayList-增删慢，改查快"><a href="#ArrayList-增删慢，改查快" class="headerlink" title="ArrayList(增删慢，改查快)"></a>ArrayList(增删慢，改查快)</h3><ul><li><p>底层是数组</p></li><li><p>默认参数化容量是10，每次扩容为原先容量的1.5倍</p></li><li><p><strong>增删时，用数组拷贝复制</strong></p></li><li><p>删除元素时不会减少容量，<strong>若希望减少容量则调用trimToSize()</strong></p></li></ul><h3 id="Linkedlist-改查慢，增删快"><a href="#Linkedlist-改查慢，增删快" class="headerlink" title="Linkedlist(改查慢，增删快)"></a>Linkedlist(改查慢，增删快)</h3><p>底层是<strong>双向链表</strong>【双向列表便于实现往前遍历】</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>底层是数组，基本被ArrayList代替，原因如下：</p><ol><li><p>所有方法都是同步的，有性能损失。</p></li><li><p>初始长度是10，超过后以100%增长，<strong>相比ArrayList更消耗内存</strong></p></li></ol><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>ArrayList的增删慢并不是绝对的</p><ol><li><p>如果增加的一直是add()增加到末尾的话</p></li><li><p>一直删除末尾的元素</p></li><li><p>如果删除中间位置的元素，还是ArrayList快</p></li></ol><p>但是一般来说：增删多还是用LinkedList</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>存取无序，元素不可重复，set也是Collection的子接口</p><ul><li><p>可以使用迭代器</p></li><li><p>可以使用增强for</p></li><li><p>不能使用索引</p></li></ul><h3 id="HashSet-数组-链表-红黑树"><a href="#HashSet-数组-链表-红黑树" class="headerlink" title="HashSet(数组+链表+红黑树)"></a>HashSet(数组+链表+红黑树)</h3><p>原则参考HashMap</p><ol><li><p>实现了Set接口</p></li><li><p>实际上是HashMap</p></li><li><p>可以存放一个null</p></li><li><p>不能重复，存取无序</p></li></ol><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>LinkedHashSet继承了HashSet，底层是一个LinkedHashMap，底层维护了一个双向链表。每一个节点都有before和after属性，添加元素的原则和hashset一样</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ol><li><p>map和collection并列，用于保存有映射关系的数据：ket-value</p></li><li><p>key和value可以是任何引用类型的数据，会被封装到HashMap$Node对象中</p></li><li><p>key值不可以重复，value可以重复</p></li><li><p>key值只能有一个null，value可以有多个null</p></li><li><p>常用String类作为Map的key</p></li><li><p>添加相同的key，相当于修改value</p></li></ol><h3 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h3><p>1.通过set取出所有的key，然后通过for进行遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">keyset</span> <span class="operator">=</span> map.Keyset();</span><br><span class="line"><span class="keyword">for</span>(Object key : keyset)&#123;</span><br><span class="line">  System.out.println(key + <span class="string">&quot; - &quot;</span>+ map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.迭代器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> keyset.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">  System.out.println(key + <span class="string">&quot; - &quot;</span>+ map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.4.同1、2取出value</p><p>5.通过EntrySet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">entryset</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line"><span class="keyword">for</span>(Object entry:entrySet) &#123;</span><br><span class="line">  Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;</span><br><span class="line">  System.out.println(m.getKey() + <span class="string">&quot;-&quot;</span> + m.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap-数组-链表-红黑树"><a href="#HashMap-数组-链表-红黑树" class="headerlink" title="HashMap(数组+链表+红黑树)"></a>HashMap(数组+链表+红黑树)</h3><p>数组用来存储元素数据，链表解决冲突，红黑树提高查询效率。</p><ol><li><p>如果链表长度&gt;8&amp;数组大小≥64，链表转为红黑树</p></li><li><p>红黑树节点数&lt;6，转为链表</p></li></ol><p>put的过程：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/329d9e53605d4579b2fc47cf9e9932c7~tplv-k3u1fbpfcp-watermark.awebp"></p><p>哈希值为32位int类型，计算的新哈希值是16高位和16低位异或，然后对数组长度（初始16）取模，取模的方法是和15进行&amp;操作，直接保留后几位二进制数。</p><p>如果传入的不是2 的整数次方时，则向上找到2的整数次方大小，比如传入17是应该找到32。</p><p>哈希函数的构造方法：除留取余法、直接定址法、数字分析法、平方取中法、折叠法</p><p>扩容要rehash，十分耗时，为什么扩容因子取0.75？如果取得比较大，元素很多空位很少才扩容，那么发生哈希冲突的概率就增大了，查找的时间成本增加。如果设置比较小，查找时间成本降低，但是需要更多的空间，空间成本增加了。</p><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>hashtable和hashmap的使用方法基本一样，他是线程安全的，但键和值都不能为null</p><table><thead><tr><th></th><th>线程安全</th><th>效率</th><th>运行null键null值</th></tr></thead><tbody><tr><td>HashMap</td><td>不安全</td><td>高</td><td>可以</td></tr><tr><td>Hashtable</td><td>安全</td><td>较低</td><td>不可以</td></tr></tbody></table><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p>使用特点和Hashtable类似，properties还可以用于从xxx.properties文件中加载数据到properties对象进行读取和修改，xxx.properties文件通常作为配置文件</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="1-先判断存储的类型（单列或双列）"><a href="#1-先判断存储的类型（单列或双列）" class="headerlink" title="1.先判断存储的类型（单列或双列）"></a>1.先判断存储的类型（单列或双列）</h3><h3 id="2-单列：collection接口"><a href="#2-单列：collection接口" class="headerlink" title="2.单列：collection接口"></a>2.单列：collection接口</h3><h4 id="允许重复：List"><a href="#允许重复：List" class="headerlink" title="允许重复：List"></a>允许重复：List</h4><ol><li><p>增删多：LinkedList</p></li><li><p>改查多：ArrayList</p></li></ol><h4 id="不允许重复：Set"><a href="#不允许重复：Set" class="headerlink" title="不允许重复：Set"></a>不允许重复：Set</h4><ol><li><p>无序：hashset</p></li><li><p>排序：TreeSet</p></li><li><p>插入和取出顺序一致：LinkedHashSet</p></li></ol><h3 id="3-双列：Map"><a href="#3-双列：Map" class="headerlink" title="3.双列：Map"></a>3.双列：Map</h3><ol><li><p>键无序：HashMap</p></li><li><p>键排序：TreeMap</p></li><li><p>键插入和取出顺序一致：LinkedHashMap</p></li><li><p>读取文件Properties</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>javaIO</title>
      <link href="/2021/12/12/java/javaIO/"/>
      <url>/2021/12/12/java/javaIO/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h1><h2 id="Java-IO中常用的类"><a href="#Java-IO中常用的类" class="headerlink" title="Java IO中常用的类"></a>Java IO中常用的类</h2><p><img src="/gallery/img/javaIO/IO%E4%B8%BB%E8%A6%81%E7%B1%BB.webp" alt="IO主要类.webp"></p><p>整个java.io包中最重要的就是五个类和一个接口。五个类是指：File、OutputStream、InputStream、Writer、Reader；一个接口是指Serializable</p><p>java I&#x2F;O主要包含三个部分：</p><p><strong>1.流式部分</strong>—IO的主体部分；</p><p><strong>2.非流式部分</strong>—主要包含一些辅助流式部分的类，如：File类、RandomAccessFile类和FileDescriptor类</p><p><strong>3.其他类</strong>—文件读取部分的与安全相关的类，如：SerializablePermission类，以及与本地操作系统相关的文件系统类，如：FileSystem类和Win</p><p>32FileSystem类和WinNTFileSystem类</p><p>主要的类如下</p><ol><li><p>File（文件特征与管理）：用于文件或者目录的描述信息，例如：生成新目录，修改文件名，删除文件，判断文件所在路径等。</p></li><li><p>InputStream（二进制格式操作）抽象类，基于字节的输入，是所有输入流的父类。</p></li><li><p>OutputStream（二进制格式操作）抽象类，基于字节的输出，是所有输出流的父类。</p></li><li><p>Reader（文件格式操作）：抽象类，基于字符的输入</p></li><li><p>Writer（文件格式操作）：抽象类，基于字符的输出</p></li><li><p>RandomAccessFile（随机文件操作）：一个独立的类，直接继承Object，功能丰富，可以从文件的任意位置进行存取（输入输出）操作。</p></li></ol><p><img src="/gallery/img/javaIO/IO%E4%BD%93%E7%B3%BB%E5%9B%BE.webp" alt="IO体系图.webp"></p><p><img src="/gallery/img/javaIO/IO%E6%B5%81%E5%85%A8%E7%B1%BB%E5%9B%BE.webp" alt="IO流全类图.webp"></p><h2 id="字节流和字符流的区别"><a href="#字节流和字符流的区别" class="headerlink" title="字节流和字符流的区别"></a>字节流和字符流的区别</h2><p>字节流没有缓冲区，是直接输出的，而字符流是输出到缓冲区的。因此在输出时，字节流不调用close()方法时，信息已经输出了，而字符流只有在调用close()方法关闭缓冲区时，信息才输出。要想字符流在未关闭时输出信息，则需要手动调用flush()方法。</p><p>读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</p><p>处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</p><p>结论：只要是处理纯文本数据，就优先考虑使用字符流。除此之外都使用字节流。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2021/11/01/java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2021/11/01/java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>可以把类看作函数的容器，或者表示自定义的数据类型。</p><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><ol><li><p>public：可以修饰类、类方法、类变量、实例变量、实例方法、构造方法，表示可以被外部访问。</p></li><li><p>private：可以修饰类、类方法、类变量、实例变量、实例方法、构造方法，表示不可以被外部访问，只能在类的内部使用</p></li><li><p>static：修饰类变量和类方法，也可以修饰内部类</p></li><li><p>final：修饰类变量，实例变量，表示只能被赋值一次。</p></li><li><p>protect：可以被同一个包内和子类访问。    <a href="#%E5%8C%85">包</a></p></li></ol><p>private &lt; 默认 &lt; protected &lt; public               <a href="/2021/10/25/java/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" title="字符编码">字符编码</a></p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造方法体现了多态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Point</span><span class="params">()</span> &#123;  <span class="comment">//构造器A</span></span><br><span class="line">    <span class="built_in">this</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Point</span><span class="params">( <span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;  <span class="comment">//构造器B</span></span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法可以有多个，但是和其他方法不同，构造方法特殊的地方：</p><ol><li><p>名称是固定的，与类名相同。</p></li><li><p>没有返回值，也不能有返回值。构造方法隐含的返回值是实例本身。</p></li></ol><p>构造器A调用了构造器B，其中this必须放在第一行。构造方法是用于初始化对象，如果要调用别的构造方法，就先调用别的，然后再根据自己需求进行更改，而如果自己先初始化了一部分，再调别的， 自己的修改将可能会被覆盖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="默认构造方法"><a href="#默认构造方法" class="headerlink" title="默认构造方法"></a>默认构造方法</h3><p>每一个类至少都要有一个构造方法，java编译器会自动生成一个默认的构造方法，也没有具体操作。但是一旦定义了新的构造方法，java就不会再自动生成默认的构造方法。例：如果只声明上述demo中的B构造方法，那么下面语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br></pre></td></tr></table></figure><p>就会报错，因为找不到无参构造器。</p><h3 id="私有构造方法"><a href="#私有构造方法" class="headerlink" title="私有构造方法"></a>私有构造方法</h3><p>构造方法可以用private修饰，用于以下几种场景：</p><ol><li><p>不能创建类对象，类只能被静态访问，如Math和Array类的构造方法就是私有的。</p></li><li><p>能创建类的对象，但只能被类的静态方法调用，在一些单例场景下，对象是通过静态方法获取的，静态方法来调用私有构造器创建对象，方法中会进行判断，如果已经创建过该对象，就重用这个对象。</p></li><li><p>只是用来被其他多个构造器调用，减少重复代码。类似于将重复代码提出成为一个方法。</p></li></ol><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>子类可以通过super调用父类的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">(<span class="type">int</span> number)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.number = number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chile</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>任何语言编译时都有一个相同的问题就是命名冲突，包就是用来解决这一问题。比如String类的完全限定名称就是java.lang.String</p><p>java API中所以类和接口都位于java包货javax下，java是标准包，javax是扩展包。</p><p>定义类的时候，应该先用关键字package声明其包名，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.service;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">index</span> &#123;</span><br><span class="line">  <span class="comment">//类的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h3><p>为了方便使用第三方代码，也是为了方便我们写的代码给其他人使用，程序大多都有打包的概念，将多个编译后的文件打包未一个文件，方便其他程序调用。</p><p>在java中，编译后的多个包的java class文件可以打包成一个文件，然后运行一下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvf&lt;包名&gt;.jar &lt;最上层包名&gt;</span><br></pre></td></tr></table></figure><p>例如对前面的类打包，如果inde.class位于E:\bin\org\service\index.class，则可以到目录E:\bin下然后运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvf index.jar org</span><br></pre></td></tr></table></figure><p>index.jar就是jar包，其实就是一个压缩文件。</p><h1 id="封装继承多态"><a href="#封装继承多态" class="headerlink" title="封装继承多态"></a>封装继承多态</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装就是隐藏实现细节，提供简化接口。封装是程序设计的第一原则。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>使用继承一方面可以复用代码，公共的属性和方法可以放在父类中，子类只关心子类所特有的就可以了；另一方面，不同子类的对象可以更为方便的统一处理。一个类只能继承一个父类，但是可以实现多个接口。<a href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB">接口和抽象类</a></p><h3 id="根父类Object"><a href="#根父类Object" class="headerlink" title="根父类Object"></a>根父类Object</h3><p>任何类都有一个隐藏父类object，Object没有定义属性，但是定义了一些方法。如toString()，但我们一般会对此方法重写。</p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>在子类中对父类的方法进行重写，调用子类此方法时，是调用子类新重写的方法体，而不是父类的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + x + <span class="string">&quot;,&quot;</span> + <span class="string">&quot;y&quot;</span> + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a>重写和重载</h4><p>参数签名：参数个数、类型、顺序。</p><table><thead><tr><th>重写</th><th>重载</th></tr></thead><tbody><tr><td>函数名相同</td><td>函数名相同</td></tr><tr><td>子类重写父类的方法</td><td>同一个类内</td></tr><tr><td>参数签名要相同</td><td>参数签名不同</td></tr></tbody></table><h3 id="父子类型转换"><a href="#父子类型转换" class="headerlink" title="父子类型转换"></a>父子类型转换</h3><p>向上转型：子类型的对象赋值给父类型的引用变量。</p><p>向下转型：父类型的变量赋值给子类型的引用变量。</p><p>instanceof可以检测给定的父类变量是不是某子类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();       <span class="comment">//向上转型</span></span><br><span class="line"><span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> (Child)b;         <span class="comment">//可以向下转型，因为b本身就是Child类型</span></span><br><span class="line">System.out.println(b <span class="keyword">instanceof</span> Child); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Base</span>();       <span class="comment">//声明对象</span></span><br><span class="line"><span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> (Child)b;         <span class="comment">//不可以向下转型，因为b本身不是Child类型</span></span><br><span class="line">System.out.println(b <span class="keyword">instanceof</span> Child); <span class="comment">//false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="继承权限"><a href="#继承权限" class="headerlink" title="继承权限"></a>继承权限</h3><p>修饰符中，protected表示可以被同一个包中的其他类访问，也可以被子类访问。</p><p>子类重写父类方法时，不能降低父类方法的可见性。即父类是public的时候子类只能是public；父类如果是protected，子类可以是protected或者public，即子类只能升级父类方法的可见性。</p><p>继承反应的是”is-a”的关系，子类是属于父类的，子类必须能支持父类所有对外的行为。子类减少了父类的可见性，破坏了”is-a”的关系，子类可以增加父类的行为，所以可以提升可见性。</p><p>修饰符final可以防止继承。</p><h3 id="继承破坏封装"><a href="#继承破坏封装" class="headerlink" title="继承破坏封装"></a>继承破坏封装</h3><p>子类和父类直接是细节依赖，子类扩展父类，仅仅知道父类能做什么是不够的，还要知道父类是怎么做的，而且父类的实现细节也不能随意修改，否则可能会影响子类。</p><p>如何避免？</p><ol><li><p>避免使用继承</p></li><li><p>正确使用继承</p></li></ol><h4 id="避免使用继承"><a href="#避免使用继承" class="headerlink" title="避免使用继承"></a>避免使用继承</h4><ol><li><p>使用final关键字</p></li><li><p>优先使用组合而非继承。组合即是Child类不继承Base，在类中声明Base调用其方法。</p></li><li><p>使用<a href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB">接口和抽象类</a></p></li></ol><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>父类Shape   子类Circle、Line  子类ArrowLine</p><p>变量shape可以引用任何Shape子类类型的对象，这叫多态，即一种类型的变量可以引用多种实际类型的对象。</p><p>对于shape变量，他有两个类型：类型Shape称为静态类型；类型Circle、Line、ArrowLine成为动态类型。调用方法的时候，会进行动态绑定。</p><p>多态和动态绑定时计算机程序的一种重要思维方式，使得操作对象的程序不需要关注对象的实际类型，从而可以统一处理不同对象，但又能实现对每个对象的特有行为。</p><h3 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h3><p>若Child类和Parent类都有某同名静态方法和静态变量，那么类外变量访问时要看访问变量的静态类型：静态类型是父类，则访问父类的静态方法和静态变量；如果静态类型是子类，则访问子类的静态方法和变量。看一个例子，这是父类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;父类静态变量&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">String</span> <span class="variable">m</span> <span class="operator">=</span> <span class="string">&quot;Base&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;base Static:&quot;</span> + s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了一个public静态变量s，一个public实例变量m，一个静态方法test。这是子类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;子类静态变量&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">String</span> <span class="variable">m</span> <span class="operator">=</span> <span class="string">&quot;Child&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Child Static:&quot;</span> + s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类定义了和父类重名的方法和变量。对于一个子类对象来说，他就有了两份变量和方法，在子类内部访问的时候，访问的都是子类的方法和变量，用super来访问父类的。以下是外部访问代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();       <span class="comment">//C的静态类型是Child，动态类型是Child</span></span><br><span class="line">  <span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> c;                  <span class="comment">//B的静态类型是Base 动态类型是Child</span></span><br><span class="line">  System.out.println(b.s);     <span class="comment">//b.s访问Base的静态变量输出：父类静态变量</span></span><br><span class="line">  System.out.println(b.m);     <span class="comment">//b.m访问Base的实例变量输出：Base</span></span><br><span class="line">  b.test();                      <span class="comment">//base Static:父类静态变量</span></span><br><span class="line">  System.out.println(c.s);     <span class="comment">//c.s访问Child的静态变量输出：子类静态变量</span></span><br><span class="line">  System.out.println(c.m);     <span class="comment">//c.m访问Child的实例变量输出Child</span></span><br><span class="line">  c.test();                      <span class="comment">//Child Static:子类静态变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例变量、静态变量、静态方法、private方法，都是静态绑定的。</p><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>重载是同一个类中，声明了同名函数，但是函数的参数类型或者个数不同。当调用该函数时，会匹配传入参数于之相对于的函数主体。</p><h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p>动态绑定是指在”执行期间”判断所引用的实际类型类型，根据其实际类型调用其相应的方法，new的是谁就去找谁的方法，就是动态绑定。</p><p>注：当有多个重名函数的时候，在决定调用哪个函数的过程中，首先是按照参数类型进行匹配的，即在所有重载或重写函数的版本中找到最匹配的，然后才看变量的动态类型，进行动态绑定。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;base_int_int&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">long</span> a,<span class="type">long</span> b)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;child_long_long&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> stasic <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">  <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>; <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">  c.sum(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>父类声明了两个输入类型为int的函数，子类为两个long，若调用sum函数时的两个参数是int类型，输出为base_int_int。</p></li><li><p>父类声明输入类型为int a和long b，子类为两个long，调用函数输入为两个int类型时输出base_int_long。此时父类子类的两个方法类型都不匹配，但是调用的是父类的代码，因为父类的更匹配一些。</p></li><li><p>父类和子类都是int a和long b，调用函数仍然是输入两个int类型的参数，此时父子函数类型都是一样的，则进行动态绑定，调用子类的函数，输出child_int_long。</p></li></ol><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型将接口的概念进一步扩展，就是广泛的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">  T first;</span><br><span class="line">  T second;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first,T second)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.first = first;<span class="built_in">this</span>.second = second;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">getfirst</span><span class="params">()</span> &#123;<span class="keyword">return</span> first;&#125;</span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">getsecond</span><span class="params">()</span> &#123;<span class="keyword">return</span> second;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pair&lt;Integer&gt; minmax = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;Integer&gt;(<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">min</span> <span class="operator">=</span> minmax.getfirst();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">max</span> <span class="operator">=</span> minmax.getsecond();</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;U, V&gt; &#123;</span><br><span class="line">  U first;</span><br><span class="line">  V second;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(U first,V second)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.first = first;<span class="built_in">this</span>.second = second;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> U <span class="title function_">getfirst</span><span class="params">()</span> &#123;<span class="keyword">return</span> first;&#125;</span><br><span class="line">  <span class="keyword">public</span> V <span class="title function_">getsecond</span><span class="params">()</span> &#123;<span class="keyword">return</span> second;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pair&lt;Integer, String&gt; pair= <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;Integer,String&gt;(<span class="number">100</span>, <span class="string">&quot;老马&quot;</span>);</span><br><span class="line">Pair&lt;Integer, String&gt; pair= <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">100</span>, <span class="string">&quot;老马&quot;</span>);  <span class="comment">//java7后可简写</span></span><br><span class="line">Pair&lt;String, String&gt; kv= <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;老马&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>泛型参数类型到底是什么呢？其实在java编辑器将java源代码转化为.class文件时，就会将泛型代码转化为普通的非泛型代码，将T、U、和V类型擦除，替换成Object，强调，java泛型是通过擦除实现的。那为什么不直接用Object而选择泛型呢？</p><ol><li><p>更好的安全性</p></li><li><p>更好的可读性</p></li></ol><p>编译无误，运行报错</p><p>使用泛型是，在程序调用中有类型错误时编译器是会有提示，但是Object不会有提示</p><p>编译报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;老马&quot;</span> ,<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> (Integer)pair.getfirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String)pair.getsecond();</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String,Integer&gt; pair = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;老马&quot;</span> ,<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> pair.getfirst();    <span class="comment">//有编译错误</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pair.getsecond();  <span class="comment">//有编译错误</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>泛型讲数据结构和算法与数据类型相对分离，使得一套数据结构和算法可以用于各种数据类型，而且保证数据类型安全，提高可读性。</p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p><code>&lt;?&gt; </code>表示所有类型</p><p><code>&lt;? extends E&gt;</code> 表示E和E的子类型</p><p><code>&lt;? super E&gt;</code> 表示E和E的父类型</p><h2 id="细节和局限性"><a href="#细节和局限性" class="headerlink" title="细节和局限性"></a>细节和局限性</h2><h3 id="使用泛型类、方法和接口"><a href="#使用泛型类、方法和接口" class="headerlink" title="使用泛型类、方法和接口"></a>使用泛型类、方法和接口</h3><ol><li><p>基本类型不能用于实例化类型参数</p></li><li><p>运行时类型信息不适用于泛型（不易理解）</p></li><li><p>类型擦除可能会引发一些冲突（不易理解）</p></li></ol><h3 id="定义泛型类、方法和接口"><a href="#定义泛型类、方法和接口" class="headerlink" title="定义泛型类、方法和接口"></a>定义泛型类、方法和接口</h3><ol><li><p>不能通过类型参数创造对象</p></li><li><p>泛型类类型参数不能用于静态变量和方法</p></li></ol><h3 id="泛型和数组"><a href="#泛型和数组" class="headerlink" title="泛型和数组"></a>泛型和数组</h3><p>不能创建泛型数组，因为泛型数组类型可能会和复制内容泛型类型不匹配，引起报错。</p><h1 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>使用interface声明接口，修饰符一般都是public。接口内声明的方法都没有定义方法体，java8之前接口内不能实现方法。接口方法不需要加修饰符，加不加都相当于是public abstract</p><ol><li><p>一个类可以实现多个接口</p></li><li><p>一个类可以继承类并实现接口</p></li><li><p>一个接口可以继承多个接口</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">Interface1</span>, Interface2 &#123;&#125;   <span class="comment">//一个类可以实现多个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_">Base</span> <span class="keyword">implements</span> <span class="title class_">Interface1</span> &#123;&#125;  <span class="comment">//一个类可以继承类并实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IChild</span> <span class="keyword">extends</span> <span class="title class_">IBase1</span>, IBase2 &#123;&#125;        <span class="comment">//一个接口可以继承多个接口</span></span><br></pre></td></tr></table></figure><p>接口中可以定义变量，修饰符是public static final，可写可不写都是。变量可以通过”接口名.变量名”调用，例Inferface1.a。</p><p>instanceof用来判断一个对象是否实现了某接口，<code>p instanceof Inferface01   //返回值是Boolean类型值 </code></p><p>使用接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyComparable</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="type">MyComparable</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Point类实现了MyComparable接口，所有可以声明p1和p2是MyComparable类型的变量，引用Point类型的对象。此时p1和p2都可以调用MyComparable 接口的方法也只能调用它的方法。</p><p>java8和java9中对接口做了一些增强。<a href="/2021/01/20/java/java8%E6%96%B0%E7%89%B9%E6%80%A7/">java8</a></p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类是相对于具体类而言的，一般来讲，具体类有直接对应的对象，而抽象类一般是用来继承。抽象类不让创建对象。</p><p>抽象类和抽象方法需要用abstract关键词声明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>接口</th><th>抽象类</th></tr></thead><tbody><tr><td>不能用于创建对象</td><td>不能用于创建对象</td></tr><tr><td>都是抽象方法</td><td>可以是抽象方法，也可以写方法体</td></tr><tr><td>不能定义实例变量</td><td>可以定义实例变量</td></tr><tr><td>可以实现多个接口</td><td>只能继承一个抽象类</td></tr></tbody></table><p>抽象类和接口是相互配合，而不是代替，他们经常一起使用，接口声明能力，抽象类实现默认实现，实现全部或者部分方法，一个接口经常有一个对应的抽象类。</p><h1 id="枚举（了解）"><a href="#枚举（了解）" class="headerlink" title="枚举（了解）"></a>枚举（了解）</h1><p>枚举也是一种属性类型，他的取值是有限的可以枚举出来的，比如一年四季，一周七天。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">  SMALL, MINDIUM, LARGE</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Size</span> <span class="variable">size</span> <span class="operator">=</span> Size.SMALL;</span><br></pre></td></tr></table></figure><p>所有枚举类型都有<code>name()</code>方法和<code>toString()</code>方法返回内容一样。枚举的equals和&#x3D;&#x3D;的返回值是一样的。</p><p>枚举类型有一个<code>int ordinal()</code>方法，返回枚举值在声明时的顺序，从0开始。</p><p>compareTo方法可以比较两个枚举类型的位置之差。</p><h1 id="常用基础类"><a href="#常用基础类" class="headerlink" title="常用基础类"></a>常用基础类</h1><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><table><thead><tr><th>基本数据类型</th><th>byte</th><th>short</th><th>int</th><th>long</th><th>float</th><th>double</th><th>char</th><th>boolean</th></tr></thead><tbody><tr><td>对应包装类</td><td>Byte</td><td>Short</td><td>Integer</td><td>Long</td><td>Float</td><td>Double</td><td>Character</td><td>Boolean</td></tr></tbody></table><p><img src="/gallery/img/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9B%BE%E7%89%87.webp" alt="包装类图片.webp"><br>8个包装类都实现了Serializable , Comparable 接口</p><h3 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h3><p>装箱：将基本类型转化为包装类型的过程叫装箱。</p><p>拆箱：将包装类型转化为基本类型的过程叫拆箱。</p><p>JDK1.5之前没有自动装箱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>); <span class="comment">//手动装箱1</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>); /手动/装箱<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> integer.intValue(); <span class="comment">//手动拆箱</span></span><br></pre></td></tr></table></figure><p>JDK1.5之后有自动装箱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">one</span> <span class="operator">=</span> <span class="number">1</span>;      <span class="comment">//自动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">two</span> <span class="operator">=</span> one + <span class="number">10</span>;   <span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure><p>其实自动拆装箱和手动拆装箱本质上是一样的。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><p>包装类都重写了equals方法，他的比较运算结果和&#x3D;&#x3D;的结果是一样的。</p><h4 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h4><p>hashcode返回一个对象的哈希值，是一个int类型的数，一个对象的哈希值不能改变，相同对象的哈希值必须一样。</p><p>hashcode和equals的联系：如果两个对象equals为true，则hashcode也必须一样。反之则不要求，如果equals返回值为false时，hashcode可以一样也可以不一样。</p><p>String的hashcode是每个字符*31的n-1次方相加，用31的(n-1)次方可能有两个原因：1.方便生成更分散的散列。2.31*h&#x3D;32*h-h，按位计算和减法计算代替乘法，加快计算速率。</p><h4 id="comparable"><a href="#comparable" class="headerlink" title="comparable"></a>comparable</h4><p>包装类都继承了comparable接口，有一个compareTo的方法，当比较式在小于、等于、大于参数是对应返回-1、0、1。注：0.1和0.1*0.1比较结果并不为0。</p><h3 id="String、StringBuffer和StringBuilder"><a href="#String、StringBuffer和StringBuilder" class="headerlink" title="String、StringBuffer和StringBuilder"></a>String、StringBuffer和StringBuilder</h3><table><thead><tr><th>String</th><th>Stringbuffer</th><th>StringBuilder</th></tr></thead><tbody><tr><td>不可变</td><td>可变</td><td>可变</td></tr><tr><td></td><td>线程安全</td><td>线程不安全</td></tr><tr><td></td><td>多线程操作字符串</td><td>单线程操作字符串</td></tr></tbody></table><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>String是被final修饰的，不能被继承，也不能被修改，JDK9之前是char[]，JDK9之后是byte[]，String创建之后不能修改，底层方法区维护了一个字符串常量池，实现共享。都是用unicode编码，一个字符占两个字节。</p><h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><p>StringBuilder是可变类和线程不安全字符操作类，字符串操作不会产生新的对象，每个StringBuilder对象都有一个缓冲区容量，超过该容量时会增加容量。效率高</p><h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><p>StringBuffer是可变类和线程安全字符操作类，字符串操作不会产生新的对象，每个StringBuffer对象都有一个缓冲区容量，超过该容量时会增加容量。效率低</p><h4 id="可变类"><a href="#可变类" class="headerlink" title="可变类"></a>可变类</h4><p>有三个构造方法<code>StringBuffer()``,``StringBuffer(int capacity)``,``StringBuffer(String ``str)</code></p><p><code>StringBuffer()</code>初始容量为16，<code>StringBuffer(int capacity)</code>初始容量是capacity，<code>StringBuffer(String ``str)</code>初始容量是<code>str.length()+16</code></p><p>扩容：当容量满后，计划扩容2*n+2,如果追加的长度仍然超出，则扩容为n+count，count为追加长度。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li><p>如果修改次数少用String</p></li><li><p>如果修改次数多，且单线程操作用StringBuilder</p></li><li><p>如果修改次数多，且多线程操作用StringBuffer</p></li><li><p>StringBuffer和StringBuilder的区别就在于StringBuffer的操作使用synchronized关键字加了锁，是线程安全的。</p></li></ol><h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><ol><li><p>exit退出程序</p></li><li><p>arraycopy复制数组</p></li><li><p>currentTimeMillens返回当期时间毫秒数</p></li><li><p>System.gc()  gc运行垃圾回收机制 <a href="https://www.wolai.com/95XQQqQUQZk3hXVKr6CUGq" title="垃圾收集器">垃圾收集器</a></p></li></ol><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>math的都是静态方法</p><table><thead><tr><th>abs</th><th>返回绝对值</th><th>pow(2,4)</th><th>返回 2的4次方</th></tr></thead><tbody><tr><td>min&#x2F;max</td><td>返回最大值&#x2F;最小值</td><td>ceil</td><td>向上取整double类型</td></tr><tr><td>random</td><td>[0,1)随机数</td><td>floor</td><td>向下取整</td></tr><tr><td>sqrt</td><td>求开方</td><td>round</td><td>四舍五入</td></tr></tbody></table><h2 id="Array类"><a href="#Array类" class="headerlink" title="Array类"></a>Array类</h2><table><thead><tr><th>Arrays.toString(arr)</th><th>显示数组</th><th>Arrays.sort(arr)</th><th>冒泡排序</th></tr></thead><tbody><tr><td>Array.copyOf(arr,arr.length)</td><td>拷贝arr.length到新数组中，如果大于arr，则新数组加空</td><td>fill(arr,22)</td><td>用22替换所有元素</td></tr><tr><td>Arrays.toString(arr，new Comparator())</td><td>可重写排序，定制排序</td><td>Array.asList(arr)</td><td>转化为List集合</td></tr><tr><td>binarySearch(arr,1)</td><td>二分法查找有序数组,如果不存在返回-(应该存在的位置+1)</td><td>equals</td><td>重写了</td></tr></tbody></table><h2 id="大数据类"><a href="#大数据类" class="headerlink" title="大数据类"></a>大数据类</h2><h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h3><table><thead><tr><th>函数</th><th>描述</th><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>BigInteger.add(a)</td><td>加</td><td>BigInteger.multiply(a)</td><td>乘</td></tr><tr><td>BigInteger.subtract(a)</td><td>减</td><td>BigInteger.divide(a)</td><td>除</td></tr></tbody></table><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><table><thead><tr><th>函数</th><th>描述</th><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>BigDecimal.add(a)</td><td>加</td><td>BigDecimal..multiply(a)</td><td>乘</td></tr><tr><td>BigDecimal.subtract(a)</td><td>减</td><td>BigDecimal..divide(a,BigDecimal.ROUND_CEILING)</td><td>除(如果有无限循环，将保留分子精度)</td></tr></tbody></table><h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><h3 id="第一代日期类"><a href="#第一代日期类" class="headerlink" title="第一代日期类"></a>第一代日期类</h3><p>java.util.Date</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();                             <span class="comment">//获取当前时间 美国格式</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1231534</span>);                      <span class="comment">//获取通过毫秒数当前时间</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;&quot;</span>);  <span class="comment">//格式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> sdf.format(d1);                   <span class="comment">//format:将日期转化为指定格式</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">parse</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;格式化好的日期&quot;</span>);          <span class="comment">//将string转为Date</span></span><br></pre></td></tr></table></figure><h3 id="第二代日期类"><a href="#第二代日期类" class="headerlink" title="第二代日期类"></a>第二代日期类</h3><p>java.util.Calendar</p><ol><li><p>Calendar是抽象类，构造器是私有的</p></li><li><p>通过getInstance()获取实例</p></li></ol><p>Calendar的问题</p><ol><li><p>可变性</p></li><li><p>偏移性：月份是0开始的</p></li><li><p>格式化：格式化只对Date有用，对Calendar没用</p></li><li><p>线程不安全，不能处理闰秒</p></li></ol><h3 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h3><p>java.time.*</p><p>LocalDate包含日期，LocalTime包含时间，LocalDateTime包含日期+时间</p><h3 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormat dtf= DateTimeFormatter.ofPattern(格式);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> dtf.format(日期对象);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符编码</title>
      <link href="/2021/10/25/java/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
      <url>/2021/10/25/java/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h1><h2 id="非Unicode编码"><a href="#非Unicode编码" class="headerlink" title="非Unicode编码"></a>非Unicode编码</h2><h3 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h3><p>ASCII码首先是为了满足美国使用，大概只需要128个字符，规定了128个字符的二进制表示方法，128刚好用7位表示，计算机最小的单位byte是8位，ASCII码中首位置0，剩下7位表示字符。</p><p>0~127中32~126表示的都是可打印字符，包含了大多数常用字符，0~31和127表示的不可打印字符，一般用于控制目的。</p><h3 id="ISO-8859-1（了解）"><a href="#ISO-8859-1（了解）" class="headerlink" title="ISO 8859-1（了解）"></a>ISO 8859-1（了解）</h3><p>又称Latin-1，使用一个字节表示一个字符，其中0~127一样，128~159表示一些控制字符，160~255表示一些西欧字符。</p><h3 id="Windows-1252"><a href="#Windows-1252" class="headerlink" title="Windows-1252"></a>Windows-1252</h3><p>ISO 8859-1虽然是为西欧国家制定的，但是标准早于欧元导致连欧元符号€都没有，Windows-1252基本代替他，在很多应用中即使声明采用ISO编码，解析的时候却依然会当作Window解析。</p><p>区别：Windows在ISO的基础上，在128~159直接使用了一些可打印字符。</p><h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><p>GB2312是第一个中文标准，采用两个字节表示一个汉字，其中最高位都是1，如果是0就认为是ASCII码。两个字节中高位0xA1~0xF7,低位是0xA1~0xFe,能表示约7000个汉字和一些罕用词和繁体字。</p><h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h3><p>GBK建立在GB2312基础上，向下兼容GB2312。GBK增加了14000多汉字，共计约21000个汉字。同样使用两个字节表示，其中高位字节范围0x81~0xFE，低位字节范围0x40~0x7E和0x80~0xFE。</p><p>注意：低位字节是从0x40开始的，说明低位字节的最高位可能是0，哪如何区分是汉字还是ASCII码？</p><p>答：汉字是由两个字节表示，在解析的时候，只要第一个字节最高位是1，那么就将下一个字节连起来解析成一个汉字，而不用考虑他的最高位，解析完后跳到第三个字节继续解析。</p><h3 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h3><p>GB18030向下兼容GBK，新增55000字符，共76000个字符，包括少数民族字符，以及中日韩统一字符。GB18030中有的是两个字符，有的是四个字符。两个字符的表示和GBK一样，四个字符中第二个字节从0x30~0x39，以此区分是两个字节表示还是4个字节表示一个字符。</p><h3 id="Big5"><a href="#Big5" class="headerlink" title="Big5"></a>Big5</h3><p>Big5针对繁体中文，规范应用于中国台湾和香港等地区，包括13000多繁体字，使用两个字节表示。</p><h2 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h2><p>Unicode编码给世界上所有字符分配了一个唯一的数字编号，从0x000000~0x10FFFF，包括110万，但大多数常用字符都在0x0000~0xFFF之间，他并没有规定每个字符怎么对应到二进制上，讲编码对应到二进制上，讲交给UTF-32、UTF-16、UTF-8来完成。</p><p>UTF-32用四个字节表示一个字符，不对应ASCII码。</p><p>UTF-16大部分用两个字节表示，少部分用4个字节表示，不对应ASCII码。</p><p>UTF-8用3个字节表示汉字，1个字节表示英文，对应ASCII码</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程基础</title>
      <link href="/2021/10/20/java/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/10/20/java/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="编程基础"><a href="#编程基础" class="headerlink" title="编程基础"></a>编程基础</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol><li><p>整数类型（byte&#x2F;short&#x2F;int默认&#x2F;long）</p></li><li><p>小数类型（float&#x2F;double默认）</p></li><li><p>字符类型（char）</p></li><li><p>真假类型（boolean）</p></li><li><p>对象     <a href="/2021/11/01/java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/#%E7%B1%BB">类</a></p></li><li><p><a href="/2021/11/01/java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/#%E6%9E%9A%E4%B8%BE%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89">枚举（了解）</a></p></li></ol><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr0 = &#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>&#125;；</span><br><span class="line"><span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">arr</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">//不能在设定初值的时候给长度，如果设定了初值再给一个不一样的长度计算机将无所适从</span></span><br><span class="line"><span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">arr</span>[<span class="number">3</span>];</span><br><span class="line">arr2[<span class="number">0</span>] = <span class="number">1</span>; arr[<span class="number">1</span>] = <span class="number">2</span>; arr[<span class="number">2</span>] = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><ol><li><p>与&amp;</p></li><li><p>或|</p></li><li><p>非!</p></li><li><p>异或^</p></li><li><p>短路与&amp;&amp;</p></li><li><p>短路或||</p></li></ol><h2 id="条件和循环"><a href="#条件和循环" class="headerlink" title="条件和循环"></a>条件和循环</h2><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( 条件语句 ) &#123;</span><br><span class="line">  代码块</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>( 条件语句<span class="number">2</span> ) &#123;</span><br><span class="line">  代码块<span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  代码块<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="/2021/11/01/java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/#%E6%9E%9A%E4%B8%BE%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89">枚举（了解）</a>类型也可以使用swich语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>( 表达式 ) &#123;</span><br><span class="line">  <span class="keyword">case</span> 值<span class="number">1</span> :</span><br><span class="line">            代码 <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 值<span class="number">2</span> :</span><br><span class="line">            代码 <span class="number">2</span>；</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">default</span>: 代码 n+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( 条件语句 )&#123;</span><br><span class="line">  代码块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  代码块;</span><br><span class="line">&#125; <span class="keyword">while</span>( 条件语句 )</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">  代码块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i : arr) &#123;</span><br><span class="line">  代码块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>可变长度参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> ... a)</span> &#123;</span><br><span class="line">  <span class="comment">//a是可变参数，传入之后是数组形式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数重载，重复命名的函数，传入的参数类型或者个数有不同实现不同的功能。</p><h3 id="函数的调用原理"><a href="#函数的调用原理" class="headerlink" title="函数的调用原理"></a>函数的调用原理</h3><h4 id="栈的概念"><a href="#栈的概念" class="headerlink" title="栈的概念"></a>栈的概念</h4><p>计算机使用栈来存放函数调用过程中需要用到的数据，包括参数、返回地址、函数内的局部变量等。main函数的相关数据放在栈的最下面，后调用的函数在上，栈遵循先入后出，需把栈上方的函数调用后出栈后再调用栈下方的函数。</p><h4 id="堆的概念"><a href="#堆的概念" class="headerlink" title="堆的概念"></a>堆的概念</h4><p>数组和对象的实际的内容一般是分配在堆上，但存放地址的空间是分配在栈上的。当java堆中的对象从新生代到老年代，当某对象失去引用对象时，就会被java的垃圾回收gc清理。<a href="https://www.wolai.com/95XQQqQUQZk3hXVKr6CUGq" title="垃圾收集器">垃圾收集器</a></p><h4 id="递归栈溢出"><a href="#递归栈溢出" class="headerlink" title="递归栈溢出"></a>递归栈溢出</h4><p>函数代码虽然只有一份，但是在执行过程中，每调用一次，就会有一次入栈，生成一份不同的参数、局部变量和返回地址，直到栈溢出。</p><p><a href="/2021/10/25/java/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/">字符编码</a></p><h4 id="char的真正含义"><a href="#char的真正含义" class="headerlink" title="char的真正含义"></a>char的真正含义</h4><p>char本质上是一个固定占用两个字节的无符号正整数，对应于Unicode编码，用于表示那个Unicode编码对应的字符。</p><h2 id="程序编译和链接"><a href="#程序编译和链接" class="headerlink" title="程序编译和链接"></a>程序编译和链接</h2><p>从java源代码到运行程序有编译和链接两个过程。</p><p>编译是将源代码文件变成.class的一种字节码文件，这个工作一般由javac命令完成。</p><p>链接是在运行是动态执行的，.class文件不能直接运行，运行的是java虚拟机，虚拟机解析.class文件，转换为机器能识别的二进制代码，然后运行。链接就是根据引用到的类加载相应的字节码并执行。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java8新特性（还没写）</title>
      <link href="/2021/01/20/java/java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2021/01/20/java/java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="/2021/01/01/index/"/>
      <url>/2021/01/01/index/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这是第一片文章..</p><!-- <div align=center class="aspect-ratio">    <iframe src="https://player.bilibili.com/player.html?aid=474023258&&page=1&as_wide=1&high_quality=1&danmaku=0"     scrolling="no"     border="0"     frameborder="no"     framespacing="0"     high_quality=1    danmaku=1     allowfullscreen="true">     </iframe></div> --><!-- <div class="fj-gallery"><p><img src="https://source.fomal.cc/img/default_cover_1.webp" alt="p1"><br><img src="https://source.fomal.cc/img/default_cover_2.webp" alt="p2"><br><img src="https://source.fomal.cc/img/default_cover_3.webp" alt="p3"><br><img src="https://source.fomal.cc/img/default_cover_4.webp" alt="p4"><br><img src="https://source.fomal.cc/img/default_cover_5.webp" alt="p5"><br><img src="https://source.fomal.cc/img/default_cover_6.webp" alt="p6"><br><img src="https://source.fomal.cc/img/default_cover_7.webp" alt="p7"><br><img src="https://source.fomal.cc/img/default_cover_8.webp" alt="p8"><br><img src="https://source.fomal.cc/img/default_cover_9.webp" alt="p9"><br><img src="https://source.fomal.cc/img/default_cover_10.webp" alt="p10"><br><img src="https://source.fomal.cc/img/default_cover_11.webp" alt="p11"><br><img src="https://source.fomal.cc/img/default_cover_12.webp" alt="p12"> </p>          </div> --><!--Page Front-matter 用于页面配置title【必需】页面标题date【必需】页面创建日期type【必需】标籤、分类和友情链接三个页面需要配置updated【可选】页面更新日期description【可选】页面描述keywords【可选】页面关键字comments【可选】显示页面评论模块 (默认 true)top_img【可选】页面顶部图片mathjax【可选】显示 mathjax (当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)kates【可选】显示 katex (当设置 katex 的 per_page: false  false)aside【可选】显示侧边栏 (默认 true)aplayer【可选】在需要的页面加载 aplayer 的 js 和 css, 请参考文章下面的音乐 配置highlight_shrink【可选】配置代码框是否展开 (true/false)(默认为设置中 highlight_shrink 的配置) --><!-- Post Front-matter 用于文章页配置写法解释title【必需】文章标题date【必需】文章创建日期updated【可选】文章更新日期tags【可选】文章标籤categories【可选】文章分类keywords【可选】文章关键字description【可选】文章描述top_img【可选】文章顶部图片cover【可选】文章缩略图 (如果没有设置 top_img, 文章页顶部将显示缩略图，可设为 false / 图片地址 / 留空)comments【可选】显示文章评论模块 (默认 true)toc【可选】显示文章 TOC (默认为设置中 toc 的 enable 配置)toc_number【可选】显示 toc_number (默认为设置中 toc 的 number 配置)toc_style_simple【可选】显示 toc 简洁模式copyright【可选】显示文章版权模块 (默认为设置中 post_copyright 的 enable 配置)copyright_author【可选】文章版权模块的文章作者copyright_author_href【可选】文章版权模块的文章作者链接copyright_url【可选】文章版权模块的文章连结链接copyright_info【可选】文章版权模块的版权声明文字mathjax【可选】显示 mathjax (当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)katex【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false)aplayer【可选】在需要的页面加载 aplayer 的 js 和 css, 请参考文章下面的音乐 配置highlight_shrink【可选】配置代码框是否展开 (true/false)(默认为设置中 highlight_shrink 的配置)aside【可选】显示侧边栏 (默认 true) -->]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
